--[[
    Error Documentation
    0  :  Successful Operation
    1  :  Port is open
    2  :  Port is closed
    3  :  Modem cannot open port (Maximum number of ports)
    4  :  No Modems attached
    5  :  Port is out of range
    11 :  Reply Port is not open
    16 :  Parameter must be a non-negative
    21 :  Timeout has expired
]]

-- NOTE: Origin will later be called out of a global Interface variable auto-generated by settings upon installation.

--- Prepares and builds a Warnet message to be sent. Further changes can be made with other functions. 
---@param message any The initial message to attach
---@param ... any? The initial destinations to attach. Can be added later using addRecipients(builtData, recipients)
---@return table WarnetMessage The resulting table for the Warnet message
build = function(message, ...)
    local origin = 1
	local dest = nil
    local args = {...}
	if #args > 1 then
		local destinations = {}
		for _,v in ipairs(args) do
			destinations[v] = true
		end
		dest = destinations
	end
    local temp = {
        Protocol = "Warnet",
        Version = "1.0.0",
        Origin = origin,
        Destination = dest,
        Message = {
            Header = nil,
            Data = message,
            Footer = nil,
            getHeader = function(o)
                return o.Header
            end,
            getData = function(o)
                return o.Data
            end,
            getFooter = function(o)
                return o.Footer
            end
        },
        getProtocol = function(o)
            return o.Protocol
        end,
        getVersion = function(o)
            return o.Version
        end,
        getOrigin = function(o)
            return o.Origin
        end,
        getDestination = function(o)
            return o.Destination
        end,
        getMessage = function(o)
            return o.Message
        end,
        isRecipient = function(o,id)
            return o.Destination[id] or false
        end
    }

    --[[
        Header: Used for complex data needed to be separated.
        Data: General data. Cannot be nil. Can be anything else, however.
        Footer: Used for security information or alternative information to be separated from Data and Header data.
        Note to self: Make a standard on the uses of each piece of information. Unsure as of now. Perhaps encryption/signatures for footers?
    ]]

    --[[
        Reason for having functions in the transmitted message itself:
        - Allows for tangential compatability with other Network Interfaces
        - Allows users to directly call functions from the categories without needing WarnetInterface installed
            > Also prevents accidential changing of data in code
    ]]

    temp.Message.__index = temp.Message
    temp.__index = temp
    return temp
end

--- Gets the message object of a built message.
---@param builtData table The Warnet message to check
---@return any messageObject The message contents of a built message
function getMessage(builtData)
    return builtData.Message
end

--- Gets the header of a message.
---@param builtData table The message (object or entire message) to check
---@return any header The header contents of a built message
function getHeader(builtData)
	if getProtocol(builtData) == nil then
		return builtData.Header
	else
		return builtData.Message.Header
	end
end

--- Gets the data of a message.
---@param builtData table The message (object or entire message) to check
---@return any data The data contents of a built message
function getData(builtData)
	if getProtocol(builtData) == nil then
		return builtData.Footer
	else
    	return builtData.Message.Data
	end
end

--- Gets the footer of a message.
---@param builtData table The message (object or entire message) to check
---@return any footer The footer contents of a built message
function getFooter(builtData)
    if getProtocol(builtData) == nil then
		return builtData.Footer
	else
		return builtData.Message.Footer
	end
end

--- Gets the destinations of a message. Which computer(s) the message was intended for.
---@param builtData table The message to check
---@return table|nil destinations The set of intended destinations, or nil if there is none
function getDestination(builtData)
    return builtData.Destination or nil
end

--- Gets the origin/source of a message. Which computer the message came from.
---@param builtData table The message to check
---@return any origin The computer which sent the message
function getSource(builtData)
    return builtData.Origin
end

--- Gets the protocol of a message, if there is one
---@param builtData table The message to check
---@return string|nil protocol The protocol that the message is using
function getProtocol(builtData)
    return builtData.Protocol
end

--- Gets a nessage version
---@param builtData table The message to get the version of
---@return string|nil version The version that the message is using
function getVersion(builtData)
    return builtData.Version
end

--- Returns whether or not the Warnet message has the computer as a recipient
---@param builtData table The message to check
---@param deviceID any The ID to check
---@return boolean result Whether or not
function isRecipient(builtData, deviceID)
	if getDestination(builtData) == nil then return false end
    -- TODO: Get the deviceID or hosts from the device's global variables
    return builtData:getDestination()[deviceID] or false
end

--- Overwrites and sets the recipients of a message
---@param builtData table The message to overwrite recipients to
---@param recipients table A table of recipients
function setRecipients(builtData, recipients)
	builtData.Destination = recipients
end

--- Adds a table of recipients to a message
---@param builtData table The message to add the recipients to
---@param recipients any The recipient(s) to add
function addRecipients(builtData, recipients)
	if type(recipients) ~= "table" then
		recipients = { recipients }
	end
	for i,v in ipairs(recipients) do
		builtData.Destination[v] = true
	end
end

--- Removes the recipients from a message
---@param builtData table The message to remove recipients from
---@param recipients any The recipient(s) to remove
function removeRecipients(builtData, recipients)
	if type(recipients) ~= "table" then
		recipients = { recipients }
	end
	for i,v in ipairs(recipients) do
		builtData.Destination[v] = nil
	end
end

--- Changes the header of a Warnet table message
---@param builtData table The message to change the header of
---@param header any The new value for the header
function setHeader(builtData, header)
    builtData.Message.Header = header
end

--- Changes the data of a Warnet table message
---@param builtData table The message to change the data of
---@param data any The new value for the data
function setData(builtData, data)
    builtData.Message.Data = data
end

--- Changes the footer of a Warnet table message
---@param builtData table The message to change the footer of
---@param footer any The new value for the footer
function setFooter(builtData, footer)
    builtData.Message.Footer = footer
end

--- Returns whether or not a table/message is Warnet compatible
---@param builtData table The message to check
---@return boolean result The result of whether the message can be read with Warnet or not
function isCompatible(builtData)
    if type(builtData) ~= "table" or string.lower(builtData.Protocol) ~= "warnet" then return false end
    return true
end

--- Returns a list of all attached modems
---@return table|nil modems The modems attached to the computer, or nil if none is found
---@return number exitCode The numeric code for how the function exited
---@return string? explanation A short string explanation for the failure
function getAllModems()
    local modems = { peripheral.find("modem") }
    if #modems < 1 then return nil, 4, "No Modems attached" end
    return modems, 0
end

--- Opens a port on a specified modem. Recommended to use (modem.open(port))
---@param port number The port to close
---@param modem table|number? The modem to open on, or the modem number (when finding modems) to open on
---@return boolean result Whether or not the function managed to open the port
---@return number exitCode The numeric code for how the function exited
---@return string? explanation A short string explanation for the failure
function openPort(port, modem)
    if port<0 or port>65535 then return false,5,"Requested port is out of range" end
    local modem = modem or 1
    if type(modem) == "number" then
        local temp = { peripheral.find("modem") }
        modem = temp[modem]
    end
    if modem.isOpen(port) then return false, 1, "Modem already has port open" end
    local status = pcall(function() modem.open(port) end)
    if status == false then
        return false, 3, "Modem cannot open port"
    end
    return true, 0
end

--- Closes a port on a specified modem. Recommended to use (modem.close(port))
---@param port number The port to close
---@param modem table|number? The modem to close on, or the modem number (when finding modems) to close on
---@return boolean result Whether or not the function managed to close the port
---@return number exitCode The numeric code for how the function exited
---@return string? explanation A short string explanation for the failure
function closePort(port, modem)
    if port<0 or port>65535 then return false,4,"Requested port is out of range" end
    local modem = modem or 1
    if type(modem) == "number" then
        local temp = { peripheral.find("modem") }
        modem = temp[modem]
    end
    if not modem.isOpen(port) then return false, 1, "Modem already has port closed" end
    modem.close(port)
    return true, 0
end

--- Closes a specified port on all attached modems
---@param port number The port to close on the modems
---@param modemList table? A list of modems to close
---@return boolean success Whether or not the function managed to close the ports
---@return number exitCode The numeric code for how the function exited
---@return string|table extra A short string explanation on failure, and a table of statuses while closing ports on success
function closePortOnAll(port, modemList)
    if port<0 or port>65535 then return false,5,"Requested port is out of range" end
    local modems
    if type(modemList) ~= "table" then
        modems = { getAllModems() }
        if modems[1] == nil then return modems[1],modems[2],modems[3] end
        modems = modems[1]
    else
        modems = modemList
    end
    local statuses = {}
    for i,modem in ipairs(modems) do
        if peripheral.getType(modem) ~= "modem" then statuses[#statuses+1] = "Peripheral is not modem." break  end
        if not modem.isOpen(port) then statuses[statuses+1] = "Port is already closed" break end
        local status, err = pcall(function() modem.close(port) end)
        if status == false then
            statuses[statuses+1] = "Unexpected error. Something went wrong."
        else
            statuses[statuses+1] = "Modem successfully closed port: "..port
        end
    end
    return true, 0, statuses
end

--- Pings a destination to check for availability
---@param destination any The destination to ping
---@param timeout number? The time before it is assumed to be unreachable
---@param returns boolean? Whether or not the command returns the results
---@return table? results The results of a ping, formatted as {false, (ExitCode), (Fail Explanation)} on fail, or {true, 0, elapsedTime} on success
function ping(destination, timeout, returns)
    timeout = timeout or 100 -- in Ticks
    if timeout < 1 then timeout = 1 end
    if type(destination) == "table" then destination = destination[1] end
    if timeout < 0 then timeout = 0 end
    local message = build("PING", destination)
    local modems = { getAllModems() }
    if modems[1] == nil then error("Error: No Modems attached!", 2) end
    local modem = modems[1]
    modem.transmit(600, 600, message)
    local timeoutTimer = os.startTimer(timeout/20)
    local startTime = os.epoch()/3600 -- translates in-game time to ticks
    local results
        while true do
            local response = { awaitMessage() }
            if response[1] == nil then
                if returns then results = { false,response[2],response[3] } end
                print(destination.." Unreachable. No response. (Timeout: "..timeout.." Ticks)")
                break
            end
            if response[1]:getMessage():getData() == "PING_REPONSE" then
                local elapsedTime = (os.epoch()/3600)-startTime
                if returns then results = { true,0,elapsedTime} end
                print("Response from "..destination..": "..elapsedTime.." Ticks for a response.")
                break
            end
        end
    if returns then return results end
    end

--- Repeatedely pings a destination a specified amount of times
---@param destination any The destination to ping
---@param times number? The amount of times to ping
---@param timeout number? The time before it is assumed to be unreachable
function repeatPing(destination, times, timeout)
    if type(times) ~= 'number' then times = 5 end
    times = times or 5
    timeout = timeout or 100
    if times>0 then
        for i=1,times do
            ping(destination, timeout)
        end
    else
        local i=1
        while true do
            ping(destination, timeout)
        end
    end
end

--- Pings multiple destinations to check for availability
---@param destinations table The destinations to ping
---@param times number? The amount of times to ping
---@param timeout number? The time before it is assumed to be unreachable
---@param returnResults boolean? Whether or not the function returns the results
---@return table? results The table of results, per destination, of pinging. Doesn't return by default.
function multiPing(destinations, times, timeout, returnResults)
    times = times or 1
    if type(times) ~= "number" then times = 1 end
    if times > 100 then times = 100 end
    if times < 1 then times = 1 end
    if type(destinations) ~= "table" then
        destinations = { destinations } --Converts the result  to a table
    end
    timeout = timeout or 100
    local pingTimes = { }
    local averages = { }
    for k,v in pairs(destinations) do
        pingTimes[k] = {}
        averages[k] = 0
    end
    for k,v in pairs(destinations) do
        print("Now pinging host: "..k)
        for i=0,times do
            local pingResult = { ping(k, timeout) }
            if pingResult[1] == true then
				pingTimes[k][#pingTimes[k]+1] = pingResult[3]
            else
				pingTimes[k][#pingTimes[k]+1] = 0
            end
        end
        local sum = 0
        for i,v2 in ipairs(pingTimes[k]) do
            sum = sum + v2
        end
        averages[k] = sum/#pingTimes[k]
        print("Host "..k.." completed! Continuing next host...")
        print("Average response time: "..averages[k])
    end
    print("Pings complete! Destination Averages:")
    for k,v in pairs(averages) do
        print(k..": "..v.." Ticks")
    end
	if returnResults then return averages end
end

--- Awaits for a Warnet compatible message on a port, then returns the message
---@param timeout number The time (in Ticks) before it exits with nil. Set to 0 for indefinite awaiting
---@param port number The port to listen for a response
---@return table|nil message the message that was recieved, or nil if no message was recieved in the timeout
---@return number exitCode the ID number for how the command exited
---@return string|number extra The reply port requested, or a string explanation on failure 
function awaitMessage(timeout, port)
    local modemTest = { getAllModems() }
    if modemTest[1] == nil then return modemTest[1], modemTest[2], modemTest[3] end
    if timeout < 0 then timeout = 0 end
    local timer = nil
    if not timeout <= 0 then timer = os.startTimer(timeout/20) end-- Divide by 20 to get ticks
    while true do
        local event = { os.pullEventRaw() }
        if event[1] == "modem message" then
            if isCompatible(event[5]) --[[and isRecipient(event[5]) (Commented until implemented fully)]] then
                if event[3] == port then
					if timer ~= nil then os.cancelTimer(timer) end
                    return event[5],0,event[4] -- Message, Receiving Port, Reply Port
                end
            end
        else if event[1] == "timer" and timer == event[2] then
                return nil,21,"The request has timed out" -- nil, Status code, Explanation
            end
        end
    end
end

--- Awaits for a Warnet compatible message on any port, then returns the message
---@param timeout number? The time before it exits with nil. Set to 0 for indefinite awaiting
---@return table|nil message the message that was recieved, or nil if no message was recieved in the timeout
---@return number exitCode the ID number for how the command exited
---@return string|number explanation-recievingPort the port which the message came in from, or a string explanation on failure 
---@return number replyPort The reply port requested, or 0 on failure
function awaitMessageUnfiltered(timeout)
    timeout = timeout or 0
    local modemTest = { getAllModems() }
    if modemTest[1] == nil then return modemTest[1], modemTest[2], modemTest[3], 0 end
    if timeout < 0 then timeout = 0 end
    local timer = nil
    if timeout <= 0 then timer = os.startTimer(timeout/20) end-- Divide by 20 to get ticks
    while true do
        local event = { os.pullEventRaw() }
        if event[1] == "modem message" then
            if isCompatible(event[5]) --[[and isRecipient(event[5]) (Commented until implemented fully)]] then
				if timer ~= nil then os.cancelTimer(timer) end
                return event[5],0,event[3],event[4]
            end
        else if event[1] == "timer" and timer == event[2] then
                return nil,21,"The request has timed out",0
            end
        end
    end
end

return {
    build = build,
    getMessage = getMessage,
    getHeader = getHeader,
    getData = getData,
    getFooter = getFooter,
    getDestination = getDestination,
    getSource = getSource,
    getProtocol = getProtocol,
    getVersion = getVersion,
    isRecipient = isRecipient,
	setRecipients = setRecipients,
	addRecipients = addRecipients,
	removeRecipients = removeRecipients,
    setHeader = setHeader,
    setData = setData,
    setFooter = setFooter,
    isCompatible = isCompatible,
    getAllModems = getAllModems,
    openPort = openPort,
    closePort = closePort,
    closePortOnAll = closePortOnAll,
    ping = ping,
    repeatPing = repeatPing,
    multiPing = multiPing,
    awaitMessage = awaitMessage,
	awaitMessageUnfiltered = awaitMessageUnfiltered
}